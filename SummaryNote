// 선언
1. 클래스명 : 대문자 시작
2. 패키지명 : 모두 소문자
3. 변수, 메소드 : 소문자 시작(여러 단어 -> 앞글자만 대문자(카멜케이스))
4. 상수 : 모두 대문자(여러 단어 -> 단어 사이에 (_) 입력(스네이크))
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 연산자
대입연산자 : 왼쪽 인자에 오른쪽 값을 대입(저장)한다는 의미

전위, 후위 연산자 이해
int i = 2, j = 0;
		j = ++i; // 연산이 먼저 진행되고 대입
		System.out.println("j는" + j + ", i는" + i);
		
		i = 2; j = 0; // 원래 값으로 초기화
		
		j = i++; // 대입이 먼저 진행되고 연산
		System.out.println("j는" + j + ", i는" + i);

연산자 우선순위 : 산술연산자 > 관계연산자(비교연산자) > 논리연산자 > 대입연산자의 순서
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// class(클래스)
1. 속성(멤버변수, 인스턴스 변수, 필드, 어트리뷰트 등) 선언
1-1 인스턴스변수
접근제어자 + 자료형 + 변수명;
1-2 클래스(static)변수(정적 변수)
접근제어자 + static + 자료형 + 변수명 = 초기화값;

2. 생성자(인스턴스 변수를 초기화 시키는 역할)
2-1 기본생성자
접근제어자 + 생성자명(클래스명과 동일해야함) + () {
}
2-2 매개변수가 있는 생성자
접근제어자 + 생성자명(클래스명과 동일해야함) + (매개변수) {
}

3. 기능(메소드, 펑션, 함수 등) 선언
3-1 인스턴스 메소드
접근제어자 + 리턴타입 + 메소드명 + (매개변수) {
기능처리
return 구문
}
3-2 클래스(static) 메소드(정적 메소드)
접근제어자 + static + 리턴타입 + 메소드명 + (매개변수) {
기능처리
return 구문
}

static 키워드가 붙으면 클래스변수, 클래스메소드가 되고(이 경우 static이 붙은 변수나 메소드가 이미 메모리에 올라가있기 때문에 인스턴스를 만들 필요없이 바로 메소드명(매개변수)로 사용가능)
static이 붙지 않은 일반적인 인스턴스변수나, 인스턴스메소드의 경우 사용할 때 클래스 인스턴스를 만들어주고 거기에서 꺼내서 사용해야함 만들어준 인스턴스변수명.메소드명(매개변수))

static 변수와 메소드에는 this 키워드를 사용할 수 없다. this는 자기자신 객체의 값을 호출하는 의미인데, static 을 사용하는 순간 모든 객체의 값을 공유한다는 의미이기 때문

매개변수가 있는 생성자를 사용하는 이유 : 매개 변수가 있는 경우 인스턴스 초기화 값에 일정 값을 넣어서 시작할 수 있다. 추후에 변경도 되기 때문에 코드를 단순화 시킬수 있다. 
-> 클래스 자체에 매개변수를 이용해서 작업을 하고싶은 경우 사용

// @Override
@Override 사용 이유 : 오버라이딩을 하려면 서브 클래스에 슈퍼 클래스 함수와 동일한 이름으로 정의되어야 하는데, 적다 오타가 나서 다른 함수가 적히면 아예 새로운 함수가 생성이 된다.
@override가 달리면 부모 클래스에서 해당 함수를 검색하는데 이 때 부모클래스에 똑같은 함수 이름이 없으면 에러가 발생 -> 오타도 잡을 수 있고 Override 한다는 것을 명시해주는 의미도 있고

// this, this(), super, super()
1.this는 현재 객체를 가리키는 키워드로 클래스 내부에서 같은 이름의 인스턴스 변수와 메소드를 구분하기 위해 사용.
ㄴ현재 클래스의 클래스 변수와 동일한 이름의 파라미터가 들어올 경우, 명확히 구분해 줄 수 있다.
2.this() : 같은 클래스에 정의된 다른 생성자를 부를때 사용된다.
3.super : 자식 클래스에서 상속받은 부모 클래스의 멤버변수나 메소드를 참조할때 사용된다.
부모, 자식 클래스의 변수/메서드 이름이 똑같을 때 구분위해 사용한다. 
4.super() : 자식 생성자 안에서 부모 클래스의 생성자를 호출할 때 사용한다
// this는 현재 클래스의 인스턴스를 가리킨다.
// super는 부모 클래스를 가리킨다.
-> 현재 클래스의 인스턴스에 있는 속성이나 함수를 제어하려면 this.setName()을 사용
-> 부모 클래스의 함수를 호출하고 싶다면 super.setName()을 사용

부모클래스의 멤버변수 접근 방식 
접근제어자가 public, protected일 때 : super.변수명으로 접근가능
접근제어자가 default일 때
(1)같은 패키지에 존재 : super.변수명으로 접근가능
(2)다른 패키지에 존재 : getter/setter를 통해 접근 super.getter/setter 사용.
접근제어자가 private일 때 : super.getter/setter.

부모클래스의 메소드 호출 방식
public, protected 메소드 : super.메소드명( );
default 메소드 : 같은 패키지에 존재하지 않으면 호출불가, 같은 패키지에 존재하면 super.메소드명( );
private 메소드 : 부모클래스의 메소드 호출불가.

getter, setter
getter : 속성의 값만 리턴하는 메소드 값의 변경이나 변경 로직은 setter에서 설정
setter : 속성의 값을 받아서 변경 또는 설정하는 메소드
-> private로 선언된 속성의 값을 수정하고자 할 때 필요하다
private으로 설정된 속성은 직접 접근이 불가하므로 객체는 입력 값을 setter 메소드의 매개값으로 넘겨주고
값을 검사하고 그 값이 필드의 값으로 적절한 경우 저장한다.
---------------------------------- getter, setter 예제 ----------------------------------------
public class Person {
    private String name;
    private int age;

    // Getter 메소드: 필드의 값을 가져오는 메소드
    public String getName() {
        return name;
    }

    // Setter 메소드: 필드의 값을 설정하는 메소드
    public void setName(String name) {
        this.name = name;
    }

    // Getter 메소드
    public int getAge() {
        return age;
    }

    // Setter 메소드
    public void setAge(int age) {
        if (age >= 0 && age <= 150) { // 나이는 일반적으로 0 이상 150 이하의 값으로 제한
            this.age = age;
        } else {
            System.out.println("올바르지 않은 나이입니다.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        
        // Setter를 사용하여 값 설정
        person.setName("John");
        person.setAge(25);
        
        // Getter를 사용하여 값 가져오기
        System.out.println("이름: " + person.getName());
        System.out.println("나이: " + person.getAge());
    }
}
--------------------------------------------------------------------------------------------
중첩클래스의 경우 외부클래스의 내부에 선언되기 때문에 접근제어자의 종류는 상관없이 받아올수있음

익명중첩클래스의 경우 구현부 중괄호 끝에 세미콜론을 붙여줘야함 

제네릭 클래스는 해 클래스에서 사용할 서브클래스라 생각 
사용할 때 타입을 지정해 줄 수 있어서 코드 재사용성과 다형성 가능 

enum에서 추상메소드는 상수마다 구현해줘야한다.
