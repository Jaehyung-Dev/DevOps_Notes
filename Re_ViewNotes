static 키워드가 붙으면 클래스변수, 클래스메소드가 되고(이 경우 static이 붙은 변수나 메소드가 이미 메모리에 올라가있기 때문에 인스턴스를 만들 필요없이 바로 메소드명(매개변수)로 사용가능)
static이 붙지 않은 일반적인 인스턴스변수나, 인스턴스메소드의 경우 사용할 때 클래스 인스턴스를 만들어주고 거기에서 꺼내서 사용해야함 만들어준 인스턴스변수명.메소드명(매개변수))

static 변수와 메소드에는 this 키워드를 사용할 수 없다. this는 자기자신 객체의 값을 호출하는 의미인데, static 을 사용하는 순간 모든 객체의 값을 공유한다는 의미이기 때문

매개변수가 있는 생성자를 사용하는 이유 : 매개 변수가 있는 경우 인스턴스 초기화 값에 일정 값을 넣어서 시작할 수 있다. 추후에 변경도 되기 때문에 코드를 단순화 시킬수 있다. 
-> 클래스 자체에 매개변수를 이용해서 작업을 하고싶은 경우 사용

@Override 사용 이유 : 오버라이딩을 하려면 서브 클래스에 슈퍼 클래스 함수와 동일한 이름으로 정의되어야 하는데, 적다 오타가 나서 다른 함수가 적히면 아예 새로운 함수가 생성이 된다.
@override가 달리면 부모 클래스에서 해당 함수를 검색하는데 이 때 부모클래스에 똑같은 함수 이름이 없으면 에러가 발생 -> 오타도 잡을 수 있고 Override 한다는 것을 명시해주는 의미도 있고

this, super 

class 내부
1. 속성(인스턴스 변수, 필드, 어트리뷰트 등) 선언
1-1 인스턴스변수
접근제어자 + 자료형 + 변수명;
1-2 클래스(static)변수
접근제어자 + static + 자료형 + 변수명 = 초기화값;

2. 생성자 
2-1 기본생성자
접근제어자 + 클래스이름(똑같아야함) + () {
}
2-2 매개변수가 있는 생성자
접근제어자 + 클래스이름(똑같아야함) + (매개변수) {
}

3. 기능(메소드, 펑션, 함수 등) 선언
3-1 인스턴스 메소드
접근제어자 + 리턴타입 + 메소드명 + (매개변수) {
기능처리
return 구문
}
3-2 클래스(static) 메소드
접근제어자 + static + 리턴타입 + 메소드명 + (매개변수) {
기능처리
return 구문
}
